#!/usr/bin/env python
#
# This script is used to delete old systests from slaves
# It requires jobs.txt file generated by cleaner_jobs.py with
# list of all jobs on slaves
#
# Delete procedure:
#  - skip environments younger then global minimal lifetime
#  - skip jobs not executed by jenkins until they pass max lifetime
#  - skip jobs which looks like latest execution in jenkins, start/execution
#    time less then 1 h (can be omitted by protect_latest)
#  - delete all job older then max lifetime
#

import datetime
import os
import re
import subprocess

#
# Definition for known systests, this dictionary should contain all known
# systest types. Each dictionary should have:
#  * env_regexp - regexp used to compare with env_prefix
#  * lifetime - time after which we can delete this job
#  * protect_latest - allow to enable protection for latest job executions,
#                     when enabled skip jobs with execution time similar
#                     to latest jenkins job execution, such env are deleted
#                     after lifetime_max
#
tests_list = [

    # custom tests run on custom CI should be kept for a day
    # could be kept for more time by request and disconnecting slave
    ('custom', {
        'env_regexp': '.*\.custom\..*',
        'lifetime': int(os.environ.get('LIFETIME_CUSTOM', 24*3)),
        'protect_latest': False,
    }),

    # SWARM tests, executed every day,
    # should be deleted before next swarm run
    ('swarm', {
        'env_regexp': '.*system_test.*',
        'lifetime': int(os.environ.get('LIFETIME_SWARM', 22)),
        'protect_latest': False,
    }),

    # BVT tests executed on every iso build, executed few times per day
    # those tests are very important and when failed are investigated asap
    # by developers, can be deleted after 24h
    ('bvt', {
        'env_regexp': '.*main.*',
        'lifetime': int(os.environ.get('LIFETIME_BVT', 24)),
        'protect_latest': True,
    }),

    # acceptance tests executed every week
    # should be investigated by QA team before next run
    # cannot be deleted before next acceptance test, need to store
    # at least 2 days
    ('acceptance', {
        'env_regexp': '.*acceptance.*',
        'lifetime': int(os.environ.get('LIFETIME_ACCEPTANCE', 48)),
        'protect_latest': False,
    }),

    # upgrade tests, executed every day or less (based on upgrade scenario)
    # should be investigated by QA team but most useful jobs runs every day
    # so cleanup should be performed before next test execution
    ('upgrade', {
        'env_regexp': '.*(?:upgrades|backup-restore).*',
        'lifetime': int(os.environ.get('LIFETIME_UPGRADE', 22)),
        'protect_latest': False,
    }),

    # fuel deployment tests, executed per-change to some fuel projects
    # should be investigated by change author
    ('fuel', {
        'env_regexp': '^env_\w+_\w+',
        'lifetime': int(os.environ.get('LIFETIME_FUEL', 72)),
        'protect_latest': False,
    }),

]

# default lifetime for not specified tests
lifetime_other = int(os.environ.get('LIFETIME_OTHER', 16))

# define minimal safety lifetime, we dont want to delete fresh systems,
# defined in hours
lifetime_minimal = 6

# define maximum lifetime, this is used for jobs which are protected by
# protect_latest variable, latest protection is not respected for enviroments
# which are longer then max lifetime
lifetime_max = 120

# define 'jenkins' user home directory
jenkins_home = '/home/jenkins'

class Cleaner():
    def __init__(self):

        # get job list from jobs.txt and prepare dictionary with run parameters
        self.prefixes = {}
        with open('jobs.txt', 'r') as jobs_all:
            for job in jobs_all:

                # get job parameters
                job_name, env_prefix, last_ts_txt = job.strip().split()

                # skip jobs without execution, it should not exists on slaves
                if last_ts_txt == 'None':
                    continue

                last_ts = \
                    datetime.datetime.fromtimestamp(float(last_ts_txt) / 1000)
                self.prefixes[env_prefix] = {
                    'job_name': job_name,
                    'latest_timestamp': last_ts.replace(microsecond=0),
                }

        # prepare list of devops envs to iterate by looking for bin/dos.py file
        self.devops = []
        # list all directories in jenkins home to find venvs
        for directory in os.listdir(jenkins_home):
            if os.path.exists(os.path.join(jenkins_home, directory, 'bin/dos.py')):
                self.devops.append(os.path.join(jenkins_home, directory))

    def start(self):
        # cleaner itself
        for devops_path in self.devops:
            print(70 * '=')
            print 'Changing environment to: ({})'.format(devops_path)
            print(70 * '=')

            # get list of local environments
            dos_path = "%s/bin/dos.py" % devops_path

            # skip non existent environment
            if not os.path.isfile(dos_path):
                print 'WARNING: VENV {} does not exists'.format(devops_path)
                continue

            local_environments = subprocess.check_output(
                [dos_path, 'list', '--timestamp']
            ).split('\n')[:-1]
            # workaround if header added
            if local_environments and local_environments[0].startswith('NAME'):
                local_environments = local_environments[2:]

            print 'Local environments found:'
            print '\n'.join('- {}'.format(x) for x in local_environments)

            for env in local_environments:
                # try to get verified data first
                try:
                    env_name, timestamp_env_local_text = env.split()
                    # get env execution time on this slave
                    timestamp_env_local = datetime.datetime.strptime(
                        timestamp_env_local_text.split('.')[0],
                        '%Y-%m-%d_%H:%M:%S'
                    ).replace(microsecond=0)
                except:
                    print 'WARNING: problem with analyse env: {}'.format(env)
                    continue

                print '\nAnalyzing {} environment:'.format(env_name)

                # get lifetime for this type of env
                (env_type, env_lifetime_hours, env_protect_latest) = \
                    self.get_job_lifetime(env_name)
                print '- env type is {0}'.format(env_type)

                # get local slave time
                timestamp_now = datetime.datetime.now().replace(microsecond=0)

                # when older then lifetime check if ready to erase
                time_diff = timestamp_now - timestamp_env_local
                if time_diff > datetime.timedelta(hours=env_lifetime_hours):
                    print '- {}h older then required {}h ({})'.format(
                        (time_diff.days * 24 + time_diff.seconds / 3600),
                        env_lifetime_hours,
                        timestamp_env_local,
                    )
                    env_prefix = self.get_prefix_by_env_name(env_name)

                    # delete all environments after max lifetime
                    if time_diff > datetime.timedelta(hours=lifetime_max):
                        print '- remove - max lifetime ({}h) passed'.format(
                            lifetime_max
                        )
                        self.local_remove_env(dos_path, env_name)
                        continue

                    # skip environment without jenkins job
                    if not env_prefix:
                        print '- cannot find related jenkins job' \
                              ', wait for max lifetime ({}h)'.format(
                            lifetime_max
                        )
                        continue

                    # get latests jenkins job execution for this prefix
                    timestamp_env_latest = \
                        self.prefixes[env_prefix]['latest_timestamp']
                    print '- jenkins job = {}'.format(
                        self.prefixes[env_prefix]['job_name']
                    )

                    print '- timestamp_env_local = %s' % timestamp_env_local
                    print '- timestamp_env_latest = %s' % timestamp_env_latest

                    # Check minimal lifetime
                    if time_diff < datetime.timedelta(hours=lifetime_minimal):
                        print '- skip - this build is too young,' \
                              ' only {}s, {}s required'.format(
                            time_diff.seconds,
                            lifetime_minimal * 3600
                        )
                        continue

                    # check latest job protection, if is set we will not delete
                    # envs which have time execution similar to latest job start
                    # additionaly check max lifetime, if job is older we can
                    # deleted it
                    time_diff_latest = \
                        timestamp_env_latest - timestamp_env_local
                    if not env_protect_latest or \
                                    time_diff_latest > datetime.timedelta(hours=1):
                        print '- remove - this build is safe to remove'
                        self.local_remove_env(dos_path, env_name)
                    else:
                        print '- skip - this build is close to latest build,' \
                              ' only {}s, {}s required'.format(
                            time_diff_latest.seconds,
                            lifetime_minimal * 3600
                        )
                else:
                    print '- skip - need {}h to analyse,' \
                          ' only {}h old ({})'.format(
                        env_lifetime_hours,
                        int(time_diff.total_seconds() / 3600),
                        timestamp_env_local
                    )

    def get_job_lifetime(self, env_prefix):
        """
        Select lifetime, based on job prefix
        """
        for param_name, param in tests_list:
            if re.match(param['env_regexp'], env_prefix):
                return param_name, param['lifetime'], param['protect_latest']
        else:
            return 'other', lifetime_other, False

    def get_prefix_by_env_name(self, env_name):
        """ get server job by local (probably suffixed) name """
        all_prefixes = self.prefixes.keys()
        # catch empty job list
        if not len(all_prefixes):
            return None
        all_prefixes.sort(key=len, reverse=True)
        for env_prefix in all_prefixes:
            if env_name.startswith(env_prefix):
                return env_prefix

    def local_remove_env(self, dos_path, env_name):
        print 'Removing: {}'.format(env_name)
        subprocess.check_output([dos_path, 'erase', env_name])


if __name__ == "__main__":
    cleaner = Cleaner()
    cleaner.start()
